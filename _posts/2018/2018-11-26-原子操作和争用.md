---
layout:     post
title:      原子操作和争用
subtitle:   总线锁和缓存行
date:       2018-11-26
author:     Lvsi
header-img: 
catalog: true
tags:
    - 原子操作
---

## 原子操作和争用

> 翻译文章来自 [《Atomic operations and contention》](https://fgiesen.wordpress.com/2014/08/18/atomics-and-contention/)<br>
> 译者：Lvsi

上周，我们介绍了缓存一致性的基本工作原理，今天，我们谈谈在缓存一致的基础之上构建一个可用的系统所需要的一些原语，以及它是如何工作的。

## 原子性和原子操作

所有这一切的关键都是原子操作，这与物理学中的原子是不相干的，和“原子”这个词的根源有关，古希腊语 “ἄτομος” (atomos, “不可分割”)。一个原子操作无法再分成更小的子操作，可能看起来是出于系统中其他核心需要的目的。要理解为什么这很重要，可以考虑这种情况：当2个核心都尝试以完全相同的方式去自增一个counter计数器时会发生什么，与之等效的是C语句中的自增语句： ```counter++```。

<img src="./images/1.png">

在编译的代码中，```counter++``` 这个单一的操作变成了 ```load```读取操作 + ```register```自增操作 + ```store```存储操作（这里写的是C式的伪代码）。这3个步骤是不同的并且会顺序执行（注意，在微架构级别x86 上也是如此，即使指令集架构上已经具有 read-modify-write 指令，如```add [memory], value```指令）。并且由于拆分为了多个循环，是可能出现在核心1已经读了```counter```并且开始自增它的时候，核心2在```counter```被核心1自增之前```read```读取到了```counter```。结果就是，即是两个核心都执行了自增```counter```的代码，但是```counter```最后的值只被增加了1次，其中的一次自增操作由于被覆盖就丢失了。

这个问题正是原子操作需要防止的，如果我们使用一个不是常规自增的原子操作（或者更简单的说是```add```操作），运行着的核心必须确保上述的3个连续的操作(```load``` + ```add``` + ```store```)看起来像是一个操作一样，这就是原子操作。当一个核心正在执行```increment```自增操作的时候，不允许其他的核心“窥视”。

## 如何实现原子操作

现在的问题是，如何做到？从概念上讲，最简单的方法是使用锁机制：在任何时间点，都只允许1个核心执行原子操作，从1个核心开始执行原子操作的时候开始锁定，当操作执行完的时候离开。这是 X86 ```LOCK``` 前缀最初使用的方法(我简化了操作，大概是这样而已)。比如，在一个原子操作中，Lock锁会在总线上传递一个消息：好吧，大家都从总线上往后退一些(对于我们来说，这意味着“停止执行内存操作”)。然后发送那个消息的核心会等待其他的核心结束当前正在执行的内存操作，之后它们会确认锁定。只有在其他的核心都确认锁定之后，这个核心才能继续工作。最后，一旦锁被释放，它再次向总线上的每一个核心发送消息：现在你们可以恢复在总线上请求了。

这很有效，但是也及其的低效， X86 CPU 依然支持这个操作(或者是等效的操作)，但是只作为一个紧急方案，当all-else-failed回退时，他们需要回退，因为x86ISA允许非常可疑的构造，例如跨越多个缓存行的未对齐原子操作，以实现向后兼容性。其他体系结构通常不允许对非自然对齐的值进行原子操作，也不允许对“太大”的值进行原子操作。这些约束保证单个原子操作始终在单个高速缓存行中进行。一旦我们有了这个，我们就处于良好状态：正如我们上次讨论缓存一致性协议时所看到的那样，核心间通信无论如何都会以高速缓存行粒度同步内存，所以原则上我们可以对单个缓存行进行复杂的修改，然后通过推送新的缓存行去发布所有更改。此外，MESI状态机具有两种状态（M和E，“修改”和“独占”），保证一个核心独占所有权 - 而高速缓存行是专有的，没有其他内核可以“窥视”。我们可以用它代替我们的锁定协议。

所以这里有一个妙语：在MESI（或派生）系统中，我们需要做的就是确保触摸单个缓存行的操作是原子的a）确保我们发出正确的内存屏障，以便正确地排序内存操作参考周围的代码（参见上一篇文章），b）在我们读取任何内容之前获取高速缓存行的独占所有权，c）如果我们在整个原子操作期间拥有独占所有权，则只回写结果。这保证了没有其他核心看到任何半成品数据。有多种方法可以完成c）。例如，我们可以构建硬件，在一个总线时钟周期内完成一组有限的原子操作; 如果我们在一个周期的开始就拥有我们的缓存行的独占所有权，我们可以在它结束时获得我们的修改数据。由于高速缓存行不可能在一个周期内“转手”，这足够快。根据总线协议，我们也可以开始玩游戏，我们立即响应一致性消息，但如果我们处于原子操作的中间，可能会稍晚发送数据。最后，我们可以决定不按时间玩游戏; 相反，我们直接实现步骤b）和c）：任何用于原子操作的高速缓存行都被“监视”，如果某个其他核心在原子操作完成之前查看我们的高速缓存行，我们需要重新开始。这就是导致这种情况的原因 最后，我们可以决定不按时间玩游戏; 相反，我们直接实现步骤b）和c）：任何用于原子操作的高速缓存行都被“监视”，如果某个其他核心在原子操作完成之前查看我们的高速缓存行，我们需要重新开始。这就是导致这种情况的原因 最后，我们可以决定不按时间玩游戏; 相反，我们直接实现步骤b）和c）：任何用于原子操作的高速缓存行都被“监视”，如果某个其他核心在原子操作完成之前查看我们的高速缓存行，我们需要重新开始。这就是导致这种情况的原因大多数RISC CPU中存在的加载链接/存储条件（LL / SC）操作。

顺便说一下，在总线端（以及因此到其他核心），正确对齐的原子操作看起来与正常的内存更新没有任何不同。同样，所有处理都是核心的内部处理; 其他内核既不知道也不关心内存是否由内存屏障或松散存储区域中的原子比较和交换操作更新。

这一切听起来既简单又简单，从概念上讲，它就是细节中的魔鬼。坏消息是，如果你是一名CPU架构师，这个过程的每一个细节都至关重要; 你的内存操作的内部实现需要避免饥饿（每个想要获得对高速缓存行的独占访问的核心应该能够这样做，最终，无论其他内核在做什么），并确保它可以实现某些基本的原子操作没有死锁或活锁。这听起来很明显，但这些保证不是自动处理原子操作或LL / SC等低级原语。这个东西很难做到，CPU需要有一个不仅正确的实现，它还需要快速的“典型案​​例”（无论它们是什么）。好消息是，如果你不是在设计CPU的公司工作，这不是你的问题，你可以放心，其他人已经考虑过这一点，由一群验证工程师提供支持，努力寻找打破它的测试用例。

